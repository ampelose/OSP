<!DOCTYPE html>
<html lang="ko">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BOM Checker</title>
  <style>
    tr.rowhl { background: #FFF3BF !important; } /* 은은한 노랑 */

    body {
      font-family: ui-sans-serif, system-ui, -apple-system;
      max-width: 1920px;
      margin: 24px auto;
      padding: 0 16px;
    }
    h1 {
      margin: 0 0 8px;
    }
    .small {
      color: #666;
      font-size: 12px;
    }
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .box {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 12px;
    }
    textarea {
      width: 100%;
      height: 200px;
      font-family: ui-monospace, Consolas, monospace;
    }
    .bar {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    button {
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #111;
      color: #fff;
      cursor: pointer;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 12px;
    }
    th,
    td {
      border: 1px solid #e5e5e5;
      padding: 6px 8px;
      font-size: 14px;
    }
    th {
      background: #fafafa;
      position: sticky;
      top: 0;
      white-space: nowrap;
      text-align: center;
    }
    .ok {
      color: #0a7f2e;
      font-weight: 700;
    }
    .pos {
      color: #1a73e8;
      font-weight: 700;
    }
    .neg {
      color: #c62828;
      font-weight: 700;
    }
    input[type="text"],
    select {
      padding: 4px 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-width: 70px;
    }
    .muted {
      color: #888;
    }
    #presetArea {
      height: 120px;
    }
  </style>

  <h1>BOM Checker</h1>
  <div class="small">
    필수 헤더: <b>P/N</b>, <b>QTY</b> · 선택: <b>Description</b>, <b>Lvl</b>,
    <b>I.S</b>
  </div>

  <div class="grid">
    <div class="box">
      <b>① 기준 목록</b>
      <textarea
        id="base"
        placeholder="엑셀에서 헤더 포함 영역을 복사해 붙여넣기"
      ></textarea>
      <div class="small">
        기준에서 품번이 <code>0</code>,<code>-</code>,<code>N/A</code> 인 행은
        자동 제외됩니다.
      </div>
    </div>
    <div class="box">
      <b>② 제출 목록</b>
      <textarea
        id="subm"
        placeholder="엑셀에서 헤더 포함 영역을 복사해 붙여넣기"
      ></textarea>
    </div>
  </div>

  <div class="box" style="margin-top: 12px">
    <div class="bar" style="margin-bottom: 6px">
      <label
        ><input type="checkbox" id="useDesc" checked /> 품번+Description 기준
        (불일치 시 품번으로 자동 매칭)</label
      >
      <label
        ><input type="checkbox" id="mergeBaseDup" /> 기준 품번 중복 통합(수량
        합산)</label
      >
      <span class="small"
        >· “중복 통합”을 켜면 기준은 품번만으로 합치고 디스크립션은 비워 품번
        매칭으로 비교합니다.</span
      >
    </div>

    <div class="bar" style="flex-wrap: wrap; gap: 12px; margin-bottom: 8px">
      <label
        ><input type="checkbox" id="advCondEnabled" /> 전역 추가
        조건(Lvl/I.S)</label
      >
      <label>Lvl 컬럼명 <input type="text" id="lvlCol" value="Lvl" /></label>
      <label
        >Lvl 입력값
        <select id="lvlVal">
          <option value=""></option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
        </select>
      </label>
      <label>I.S 컬럼명 <input type="text" id="isCol" value="I.S" /></label>
      <label
        >I.S 입력값 <input type="text" id="isVal" placeholder="예: YES, OK 등"
      /></label>
      <label
        >결합
        <select id="condMode">
          <option value="OR" selected>OR</option>
          <option value="AND">AND</option>
        </select>
      </label>
    </div>

    <div class="bar" style="flex-wrap: wrap; gap: 12px; margin-bottom: 4px">
      <label
        ><input type="checkbox" id="aggMode" /> 합산 모드(품번 단위로 제출
        합산)</label
      >
      <label
        ><input type="checkbox" id="aggCondOnly" /> 조건 충족 행만 합산</label
      >
      <span class="small">* “조건 충족 행만 합산”은 전역 추가 조건 사용.</span>
    </div>

    <!-- 사전설정 영역 -->
    <div class="box" style="margin: 8px 0; background: #fcfcfc">
      <div class="bar">
        <b>사전설정(Description 기준)</b>
        <span class="small"
          >· 형식:
          <code
            >Description[TAB]Lvl[TAB]I.S[TAB]모드(OR/AND)[TAB]품번합산(Y/N)[TAB]기준합산(Y/N)[TAB]조건사용(Y/N)</code
          >
        </span>
        <button id="presetSave">사전설정 저장</button>
        <button id="presetLoad">불러오기</button>
        <button id="presetClear" style="background: #b02a37">
          사전설정 삭제
        </button>
      </div>
      <textarea
        id="presetArea"
        placeholder="예)
ALT Assembly	4		OR	Y
CAS Assembly	1	OK	OR	N"
      ></textarea>
    </div>

    <div class="bar" style="margin-top: 6px">
      <button id="run">비교</button>
      <button id="dl" style="display: none; background: #444">
        CSV로 저장
      </button>
      <button id="resetAll" style="background: #b02a37">
        초기화(저장값 삭제)
      </button>
      <label class="small"
        ><input type="checkbox" id="resetAlsoPreset" /> 사전설정도 삭제</label
      >
      <label style="margin-left: auto"
        ><input type="checkbox" id="showCheckedOnly" /> 확인안된 행만
        보기</label
      >
      <label
        ><input type="checkbox" id="showFailedCond" /> 조건 불일치도 표시</label
      >
    </div>

    <div class="small muted" style="margin-top: 6px">
      * 결과표 우측의
      <b>조건사용/Lvl 입력값/I.S 입력값/모드/기준합산/품번합산</b>은 저장됩니다.
      새로고침해도 유지되며, <b>초기화</b>를 누르면 삭제됩니다. 사전설정은
      Description을 키로 기본값을 자동 적용합니다.
    </div>
<!-- "확인안된 행만 보기" 바로 아래 위치 -->
<div class="bar" style="margin-bottom:6px; gap:6px; justify-content:flex-end;">
  <button id="checkAll"  style="background:#2563eb;">전체 선택</button>
  <button id="uncheckAll" style="background:#6b7280;">전체 해제</button>
</div>


  <div id="out" class="box" style="display: none"></div>

  <script>
    // ===== Draft autosave keys =====
    const DRAFT_KEYS = {
      base: "draft_base_v1",
      subm: "draft_subm_v1",
      opts: "draft_opts_v1",
    };

    /* ===== 저장 키 ===== */
    const CHECK_STORE_KEY = "compare_check_map_v2";
    const PERCOND_STORE_KEY = "compare_perrow_byIndex_v3";
    const PRESET_STORE_KEY = "compare_desc_presets_v1";

    const DISABLE_GLOBALS = true;

    /* ===== 유틸 ===== */
    const esc = (s) => String(s ?? "");
    function detectSepSmart(text) {
      if (text.includes("\t")) return "\t";
      const f = text.replace(/\r/g, "").trim().split("\n")[0] || "";
      const H = ["품번", "수량", "디스크립션", "LVL", "I.S", "IS"];
      const sc = (sep) =>
        f
          .split(sep)
          .map((s) => s.trim().toUpperCase())
          .reduce((a, c) => a + (H.includes(c) ? 1 : 0), 0);
      if (f.includes(";") && sc(";") >= 2) return ";";
      if (f.includes(",") && sc(",") >= 2) return ",";
      return null;
    }
    function splitRow(row, sep) {
      return sep ? row.split(sep) : row.trim().split(/\s{2,}/);
    }
    function cleanCell(v, mode) {
      if (v == null) return "";
      let s = String(v)
        .replace(/\u00A0/g, " ")
        .replace(/\s+/g, " ")
        .trim();
      if (mode === "part") return s.toUpperCase().replace(/\s+/g, "");
      if (mode === "desc") return s.toUpperCase();
      return s;
    }
    function normalizeHeader(h) {
      return String(h || "")
        .toUpperCase()
        .replace(/[.\s]/g, "");
    }
    function parseLooseRow(line) {
      const m = line.trim().match(/^(\S+)\s+(\S+)\s*(.*)$/);
      if (!m) return { part: "", qty: "", desc: "", lvl: "", isv: "" };
      return {
        part: cleanCell(m[1], "part"),
        qty: cleanCell(m[2], "qty"),
        desc: cleanCell(m[3], "desc"),
        lvl: "",
        isv: "",
      };
    }
    function num(x) {
      if (x == null) return 0;
      const s = String(x).replace(/,/g, "").replace(/\s+/g, "");
      if (s === "" || s.toLowerCase() === "nan") return 0;
      const v = parseFloat(s);
      return isNaN(v) ? 0 : v;
    }

    /* ===== 파서 ===== */
    function parseTable(
      text,
      isBase = false,
      lvlColName = null,
      isColName = null
    ) {
      if (!text || !text.trim()) return [];
      const sep = detectSepSmart(text);
      const lines = text.replace(/\r/g, "").trim().split("\n");
      const headRaw = sep
        ? lines[0].split(sep).map((h) => h.trim())
        : splitRow(lines[0], null);
      const headNorm = headRaw.map(normalizeHeader);
      const findByLabel = (...labels) => {
        const t = labels.map(normalizeHeader);
        for (let i = 0; i < headNorm.length; i++)
          if (t.includes(headNorm[i])) return i;
        return -1;
      };
      const findByCustom = (name) => {
        if (!name) return -1;
        const t = normalizeHeader(name);
        for (let i = 0; i < headNorm.length; i++)
          if (headNorm[i] === t) return i;
        return -1;
      };
      const idxPart = findByLabel("품번", "PART", "P/N", "PN");
      const idxQty = findByLabel("수량", "QTY", "QUANTITY");
      const idxDesc = findByLabel("디스크립션", "DESCRIPTION", "DESC");
      const idxLvl = findByCustom(lvlColName);
      const idxIS = findByCustom(isColName);
      const loose = !sep || idxPart < 0 || idxQty < 0;

      const filterInvalidBase = (arr) =>
        arr.filter((x) => {
          if (!isBase) return true;
          const p = (x.part || "").toUpperCase();
          return !(p === "0" || p === "-" || p === "N/A");
        });

      if (!loose) {
        const arr = lines
          .slice(1)
          .map((row) => {
            const c = splitRow(row, sep);
            return {
              part: cleanCell(c[idxPart], "part"),
              qty: cleanCell(c[idxQty], "qty"),
              desc: idxDesc >= 0 ? cleanCell(c[idxDesc], "desc") : "",
              lvl: idxLvl >= 0 ? cleanCell(c[idxLvl], "desc") : "",
              isv: idxIS >= 0 ? cleanCell(c[idxIS], "desc") : "",
            };
          })
          .filter(
            (x) =>
              x.part !== "" ||
              x.qty !== "" ||
              x.desc !== "" ||
              x.lvl !== "" ||
              x.isv !== ""
          );
        return filterInvalidBase(arr);
      } else {
        const arr = lines
          .slice(1)
          .map(parseLooseRow)
          .filter(
            (x) =>
              x.part !== "" ||
              x.qty !== "" ||
              x.desc !== "" ||
              x.lvl !== "" ||
              x.isv !== ""
          );
        return filterInvalidBase(arr);
      }
    }

    /* ===== 기준 중복 통합(전역 옵션) ===== */
    function mergeBaseByPart(baseItems) {
      const map = new Map();
      for (const it of baseItems) {
        if (!map.has(it.part)) map.set(it.part, { part: it.part, qty: 0 });
        map.get(it.part).qty += num(it.qty);
      }
      return Array.from(map.values()).map((r) => ({
        part: r.part,
        qty: r.qty,
        desc: "",
      }));
    }

    /* ===== 버킷 ===== */
    function bucketBase(items) {
      const m = new Map();
      for (const it of items) {
        const k = it.part;
        const r = m.get(k) || {
          part: it.part,
          descs: new Set(),
          qtys: [],
          ptr: 0,
        };
        r.qtys.push(num(it.qty));
        if (it.desc) r.descs.add(it.desc);
        m.set(k, r);
      }
      return m;
    }
    function consumeBaseQty(b, key) {
      const r = b.get(key);
      if (!r) return 0;
      const i = r.ptr || 0;
      const q = i < r.qtys.length ? r.qtys[i] : 0;
      r.ptr = i + 1;
      return q;
    }
    function baseTotal(b, key) {
      const r = b.get(key);
      if (!r) return 0;
      return r.qtys.reduce((a, c) => a + c, 0);
    }

    function bucketSubRaw(items) {
      const m = new Map();
      for (const it of items) {
        const k = it.part;
        const r = m.get(k) || { part: it.part, byDesc: new Map(), rows: [] };
        r.rows.push({
          qty: num(it.qty),
          lvl: (it.lvl || "").toUpperCase().trim(),
          isv: (it.isv || "").toUpperCase().trim(),
          desc: it.desc || "",
        });
        if (it.desc) {
          const d = it.desc;
          const list = r.byDesc.get(d) || [];
          list.push(r.rows[r.rows.length - 1]);
          r.byDesc.set(d, list);
        }
        m.set(k, r);
      }
      return m;
    }

    /* ===== 로컬스토리지 ===== */
    function loadJson(key, fb) {
      try {
        return JSON.parse(localStorage.getItem(key) || fb);
      } catch (e) {
        return JSON.parse(fb);
      }
    }
    function saveJson(key, obj) {
      try {
        localStorage.setItem(key, JSON.stringify(obj));
      } catch (e) {}
    }
    let perCondMap = loadJson(PERCOND_STORE_KEY, "{}");
    let checkMap = loadJson(CHECK_STORE_KEY, "{}");
    let descPresets = loadJson(PRESET_STORE_KEY, "{}");

    /* ===== 키/조건 ===== */
    function rowKey(part, occIdx) {
      return `${String(part || "")
        .toUpperCase()
        .replace(/\s+/g, "")}||#${occIdx}`;
    }
    function keyDesc(desc) {
      return String(desc || "")
        .toUpperCase()
        .replace(/\s+/g, " ")
        .trim();
    }

    function normalizeLvl(s) {
      const t = String(s || "")
        .toUpperCase()
        .trim()
        .replace(/,/g, "");
      const m = t.match(/^[\.\u00B7\u2026\u2219\u22C5\u2022\s]*?(\d+)\s*$/);
      return m ? "#" + m[1] : t;
    }
    function checkByCond(row, cfg) {
      if (!cfg || !cfg.enabled) return { ok: true, reason: "" };
      const rowLvl = normalizeLvl(row.lvl),
        cfgLvl = normalizeLvl(cfg.lvl);
      const chk = [];
      if (cfg.lvl) {
        const ok =
          rowLvl.startsWith("#") && cfgLvl.startsWith("#")
            ? rowLvl === cfgLvl
            : String(row.lvl || "")
                .toUpperCase()
                .trim() ===
              String(cfg.lvl || "")
                .toUpperCase()
                .trim();
        chk.push(ok);
      }
      if (cfg.isv) {
        chk.push(
          String(row.isv || "")
            .toUpperCase()
            .trim() ===
            String(cfg.isv || "")
              .toUpperCase()
              .trim()
        );
      }
      if (chk.length === 0) return { ok: true, reason: "" };
      const ok = cfg.mode === "AND" ? chk.every(Boolean) : chk.some(Boolean);
      let reason = "";
      if (!ok) {
        if (cfg.lvl) {
          const mis =
            rowLvl.startsWith("#") && cfgLvl.startsWith("#")
              ? rowLvl !== cfgLvl
              : String(row.lvl || "")
                  .toUpperCase()
                  .trim() !==
                String(cfg.lvl || "")
                  .toUpperCase()
                  .trim();
          if (mis) reason += `LVL≠${cfg.lvl} `;
        }
        if (
          cfg.isv &&
          String(row.isv || "")
            .toUpperCase()
            .trim() !==
            String(cfg.isv || "")
              .toUpperCase()
              .trim()
        )
          reason += `IS≠${cfg.isv}`;
      }
      return { ok, reason: reason.trim() };
    }

    /* ===== 결과표 렌더 ===== */
    function normalizeLvlDigits(v) {
      const m = String(v || "").match(/(\d+)/);
      return m ? m[1] : "";
    }
    function renderLvlSelect(cur, cls) {
      const sel = normalizeLvlDigits(cur);
      return `<select class="${cls}">
        <option value="" ${sel === "" ? "selected" : ""}></option>
        <option value="1" ${sel === "1" ? "selected" : ""}>1</option>
        <option value="2" ${sel === "2" ? "selected" : ""}>2</option>
        <option value="3" ${sel === "3" ? "selected" : ""}>3</option>
        <option value="4" ${sel === "4" ? "selected" : ""}>4</option>
      </select>`;
    }

    function fmtSign(n) {
      const v = Number(n);
      if (!isFinite(v) || Math.abs(v) < 1e-12) return "0";
      return v > 0 ? `+${v}` : `-${Math.abs(v)}`;
    }

    let lastResult = [];
    function renderTable(rows, defaults) {
      lastResult = rows.slice();
      const outEl = document.getElementById("out");
      const filtered = document.getElementById("showCheckedOnly").checked
        ? rows.filter((r) => !checkMap[r._key])
        : rows;
      if (filtered.length === 0) {
        outEl.style.display = "none";
        return;
      }

      const agg = document.getElementById("aggMode").checked;
      const colsBase = [
        "No.",
        "품번",
        "디스크립션",
        "기준수량",
        "제출수량",
        "차이",
        "기준합산",
        "품번합산",
        "조건사용",
        "모드",
        "조건",
      ];
      const colsEdit = ["Lvl 입력값", "I.S 입력값", "판정", "확인"];
      const cols = agg ? colsBase : [...colsBase, ...colsEdit];

      let html =
        '<div style="max-height:60vh;overflow:auto"><table><thead><tr>';
      for (const c of cols) html += `<th>${c}</th>`;
      html += "</tr></thead><tbody>";

      filtered.forEach((r, i) => {
        const checked = !!checkMap[r._key];
        const rk = r._rk;
        const pKey = String(r["품번"] || "")
          .toUpperCase()
          .replace(/\s+/g, "");

        const preset = descPresets[keyDesc(r["디스크립션"])] || {};
        const rowSaved = perCondMap[rk] || {};
        const partSaved = perCondMap[pKey] || {};
        const rowCfg = {
          enabled: rowSaved.enabled ?? preset.enabled ?? false,          // ★ preset.enabled 반영
          lvl:     rowSaved.lvl ?? preset.lvl ?? defaults.lvlReq ?? "",
          isv:     rowSaved.isv ?? preset.isv ?? defaults.isReq ?? "",
          mode:    rowSaved.mode ?? preset.mode ?? defaults.condMode ?? "OR",
        };
        const partCfg = {
          aggregate: partSaved.aggregate ?? preset.aggregate ?? false,
          baseMerge: partSaved.baseMerge ?? preset.baseMerge ?? false,   // ★ preset.baseMerge 반영
        };


        html += `<tr data-rk="${rk}" data-pkey="${pKey}" data-desc="${keyDesc(
          r["디스크립션"]
        )}">`;
        cols.forEach((c) => {
          if (c === "No.") html += `<td>${i + 1}</td>`;
          else if (c === "판정") {
            const isOk = String(r[c]).toUpperCase() === "OK";
            html += `<td class="${isOk ? "ok" : "neg"}">${isOk ? "OK" : "NG"}</td>`;
          } else if (["기준수량", "제출수량"].includes(c)) {
              html += `<td>${r[c]}</td>`;
            }
            else if (c === "차이") {
              const v = Number(r[c]) || 0;
              const cls = v > 0 ? "pos" : v < 0 ? "neg" : "";
              html += `<td class="${cls}">${fmtSign(v)}</td>`;
            
} else if (c === "조건") {
            html += `<td>${r["_cond"] || ""}</td>`;
          } else if (c === "확인") {
            html += `<td style="text-align:center"><input type="checkbox" class="rowchk" data-key="${
              r._key
            }" ${checked ? "checked" : ""}></td>`;
          } else if (c === "기준합산") {
            html += `<td style="text-align:center"><input type="checkbox" class="pc-base-merge" ${
              partCfg.baseMerge ? "checked" : ""
            }></td>`;
          } else if (c === "품번합산") {
            html += `<td style="text-align:center"><input type="checkbox" class="pc-agg" ${
              partCfg.aggregate ? "checked" : ""
            }></td>`;
          } else if (!agg && c === "조건사용") {
            html += `<td style="text-align:center"><input type="checkbox" class="pc-enabled" ${
              rowCfg.enabled ? "checked" : ""
            }></td>`;
          } else if (!agg && c === "Lvl 입력값") {
            html += `<td>${renderLvlSelect(rowCfg.lvl || "", "pc-lvl")}</td>`;
          } else if (!agg && c === "I.S 입력값") {
            html += `<td><input type="text" class="pc-is" value="${
              rowCfg.isv || ""
            }"></td>`;
          } else if (!agg && c === "모드") {
            html += `<td><select class="pc-mode"><option value="OR"${
              rowCfg.mode === "OR" ? " selected" : ""
            }>OR</option><option value="AND"${
              rowCfg.mode === "AND" ? " selected" : ""
            }>AND</option></select></td>`;
          } else {
            html += `<td>${r[c] ?? ""}</td>`;
          }
        });
        html += "</tr>";
      });

      html += "</tbody></table></div>";
      outEl.innerHTML = html;
      outEl.style.display = "block";

      bindRowHover(outEl.querySelector('table'));

// ✅ 체크박스 핸들러: 필터 켜진 상태에선 리렌더 대신 행만 숨김
outEl.querySelectorAll(".rowchk").forEach((cb) => {
  cb.addEventListener("change", () => {
    const k = cb.dataset.key;
    const tr = cb.closest("tr");

    if (cb.checked) checkMap[k] = true;
    else delete checkMap[k];
    saveJson(CHECK_STORE_KEY, checkMap);

    const onlyUnconfirmed = document.getElementById("showCheckedOnly").checked;

    if (onlyUnconfirmed) {
      // 이 줄만 바로 숨기면 됨 — 리렌더 필요 없음
      tr.style.display = cb.checked ? "none" : "";

      // 선택적으로: 남은 보이는 행이 없으면 표 감추기
      const anyVisible = !!outEl.querySelector("tbody tr:not([style*='display: none'])");
      if (!anyVisible) outEl.style.display = "none";
    }
    // 필터 꺼져 있을 때는 그대로 두면 됨(리렌더 불필요)
  });
});




      if (!agg) {
        outEl.querySelectorAll("tr[data-rk]").forEach((tr) => {
          const rk = tr.getAttribute("data-rk");
          const pKey = tr.getAttribute("data-pkey");
          const en = tr.querySelector(".pc-enabled");
          const lvl = tr.querySelector(".pc-lvl");
          const isv = tr.querySelector(".pc-is");
          const md = tr.querySelector(".pc-mode");
          const aggEl = tr.querySelector(".pc-agg");
          const baseEl = tr.querySelector(".pc-base-merge");
          function save() {
            perCondMap[rk] = {
              enabled: !!(en && en.checked),
              lvl: lvl ? lvl.value : "",
              isv: isv ? isv.value : "",
              mode: md ? md.value : "OR",
            };
            const prev = perCondMap[pKey] || {};
            perCondMap[pKey] = {
              ...prev,
              aggregate: !!(aggEl && aggEl.checked),
              baseMerge: !!(baseEl && baseEl.checked),
            };
            saveJson(PERCOND_STORE_KEY, perCondMap);
          }
          [en, lvl, isv, md, aggEl, baseEl].forEach((el) => {
            if (el) el.addEventListener("change", save);
          });
          if (isv) isv.addEventListener("input", save);
        });
      }

      const dl = document.getElementById("dl");
      dl.style.display = rows.length ? "inline-block" : "none";
      dl.onclick = () => {
        const cols = [
          "No.",
          "품번",
          "디스크립션",
          "기준수량",
          "제출수량",
          "차이",
          "판정",
          "조건",
          "확인",
          "기준합산",
          "품번합산",
        ];
        const body = (
          document.getElementById("showCheckedOnly").checked
            ? rows.filter((r) => !checkMap[r._key])
            : rows
        )
          .map((r, i) => {
            const pKey = String(r["품번"] || "")
              .toUpperCase()
              .replace(/\s+/g, "");
            const partCfg = perCondMap[pKey] || {};
            return [
              i + 1,
              r["품번"],
              r["디스크립션"],
              r["기준수량"],
              r["제출수량"],
              r["차이"],
              r["판정"],
              r["_cond"] || "",
              checkMap[r._key] ? "Y" : "",
              partCfg.baseMerge ? "Y" : "",
              partCfg.aggregate ? "Y" : "",
            ]
              .map((s) => `"${String(s ?? "").replace(/"/g, '""')}"`)
              .join(",");
          })
          .join("\n");
        const csv = cols.map((s) => `"${s}"`).join(",") + "\n" + body;
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "비교결과.csv";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      };
    }

    /* ===== 실행 ===== */
    document.getElementById("run").addEventListener("click", runCompare);
    document
      .getElementById("showCheckedOnly")
      .addEventListener("change", () =>
        renderTable(lastResult, { enabled: false })
      );

    // ▼ 추가: 현재 화면(필터 적용 후)에 보이는 행 가져오기 & 일괄 체크/해제
    function getVisibleRows() {
      return document.getElementById("showCheckedOnly").checked
        ? lastResult.filter((r) => !checkMap[r._key]) // 확인 안된 행만 보기
        : lastResult.slice();
    }
    function bulkCheck(mark = true) {
      const rows = getVisibleRows();
      if (!rows.length) return;
      rows.forEach((r) => {
        if (mark) checkMap[r._key] = true;
        else delete checkMap[r._key];
      });
      saveJson(CHECK_STORE_KEY, checkMap);
      renderTable(lastResult, { enabled: false });
    }
    document
      .getElementById("checkAll")
      .addEventListener("click", () => bulkCheck(true));
    document
      .getElementById("uncheckAll")
      .addEventListener("click", () => bulkCheck(false));
    // ▲ 추가 끝

    function runCompare() {
      try {
        const useDesc = document.getElementById("useDesc").checked;
        const mergeDup = document.getElementById("mergeBaseDup").checked;
        const showFail = document.getElementById("showFailedCond").checked;
        const agg = document.getElementById("aggMode").checked;
        const aggOnly = document.getElementById("aggCondOnly").checked;

        const advEnabled = document.getElementById("advCondEnabled").checked;
        const lvlCol = document.getElementById("lvlCol").value.trim() || "Lvl";
        const isCol = document.getElementById("isCol").value.trim() || "I.S";
        const defaults = {
          enabled: advEnabled,
          lvlReq: (document.getElementById("lvlVal").value || "")
            .toUpperCase()
            .trim(),
          isReq: (document.getElementById("isVal").value || "")
            .toUpperCase()
            .trim(),
          condMode: document.getElementById("condMode").value,
        };

        let baseRaw = parseTable(
          document.getElementById("base").value,
          true,
          null,
          null
        );
        const subm = parseTable(
          document.getElementById("subm").value,
          false,
          lvlCol,
          isCol
        );

        const base = mergeDup ? mergeBaseByPart(baseRaw) : baseRaw;
        const baseBucket = bucketBase(base);
        const subBucket = bucketSubRaw(subm);

        const occ = new Map();
        let baseRows = base.map((it) => {
          const c = (occ.get(it.part) || 0) + 1;
          occ.set(it.part, c);
          return { part: it.part, desc: it.desc, occIdx: c };
        });

        // 기준합산 체크된 품번은 1행만 남김
        baseRows = baseRows.filter((br) => {
          const pKey = String(br.part || "")
            .toUpperCase()
            .replace(/\s+/g, "");
          const partCfg = perCondMap[pKey] || {};
          return partCfg.baseMerge ? br.occIdx === 1 : true;
        });

        function condOfRow(br) {
          const rk = rowKey(br.part, br.occIdx);
          const pKey = String(br.part || "")
            .toUpperCase()
            .replace(/\s+/g, "");
          const rowSaved = perCondMap[rk] || null;
          const partSaved = perCondMap[pKey] || null;
          const preset = descPresets[keyDesc(br.desc)] || {};
          return {
            enabled: rowSaved ? !!rowSaved.enabled : !!preset.enabled,     // ★
            lvl:     rowSaved ? (rowSaved.lvl ?? "") : (preset.lvl ?? ""),
            isv:     rowSaved ? (rowSaved.isv ?? "") : (preset.isv ?? ""),
            mode:    rowSaved ? (rowSaved.mode ?? "OR") : (preset.mode ?? "OR"),
            aggregate: !!((partSaved && partSaved.aggregate) || preset.aggregate),
            baseMerge: !!((partSaved && partSaved.baseMerge) || preset.baseMerge), // ★
          };

        }

        let result = [];
        if (agg) {
          const condCfgAgg = {
            enabled: defaults.enabled,
            lvl: defaults.lvlReq,
            isv: defaults.isReq,
            mode: defaults.condMode,
          };
          for (const [part, bRec] of baseBucket.entries()) {
            const bsum = baseTotal(baseBucket, part);
            const srec = subBucket.get(part);
            let ssum = 0;
            if (srec) {
              if (aggOnly && condCfgAgg.enabled) {
                for (const r of srec.rows) {
                  if (checkByCond(r, condCfgAgg).ok) ssum += r.qty || 0;
                }
              } else {
                ssum = srec.rows.reduce((a, r) => a + (r.qty || 0), 0);
              }
            }
            const delta = ssum - bsum;
            const desc =
              bRec.descs && bRec.descs.size > 0
                ? Array.from(bRec.descs)[0]
                : "";
            result.push({
              _key: `${part}||AGG`,
              _rk: `${String(part).toUpperCase().replace(/\s+/g, "")}||#AGG`,
              품번: part,
              디스크립션: desc,
              기준수량: bsum,
              제출수량: ssum,
              차이: delta,
              판정: delta === 0 ? "OK" : delta > 0 ? `+${delta}` : `-${-delta}`,
              _cond: aggOnly ? "조건합산" : "전체합산",
            });
          }
        } else {
          // 개별 매칭
          const out = [];
          const usedByKey = new Map();
          function takeNext(rows, cfg, used) {
            for (let i = 0; i < rows.length; i++) {
              if (used.has(i)) continue;
              const ev = checkByCond(rows[i], cfg);
              if (ev.ok) {
                used.add(i);
                return { row: rows[i], ok: true, reason: "" };
              }
            }
            for (let i = 0; i < rows.length; i++) {
              if (used.has(i)) continue;
              const ev = checkByCond(rows[i], cfg);
              used.add(i);
              return { row: rows[i], ok: false, reason: ev.reason };
            }
            return null;
          }
          for (const br of baseRows) {
            const cfg = condOfRow(br);
            const part = br.part,
              desc = br.desc;
            const srec = subBucket.get(part);
            if (!srec) continue;

            // 기준합산만 켠 경우: 제출 전체 합산
            if (!cfg.aggregate && cfg.baseMerge) {
              const target =
                useDesc && desc && srec.byDesc.has(desc)
                  ? srec.byDesc.get(desc)
                  : srec.rows;
              let sqty = 0;
              if (cfg.enabled && (cfg.lvl || cfg.isv)) {
                for (const r of target) {
                  if (checkByCond(r, cfg).ok) sqty += r.qty || 0;
                }
              } else {
                sqty = target.reduce((a, r) => a + (r.qty || 0), 0);
              }
              const bqty = baseTotal(baseBucket, part);
              const delta = sqty - bqty;
              out.push({
                _key: `${part}||${desc || ""}||${br.occIdx}`,
                _rk: rowKey(part, br.occIdx),
                품번: part,
                디스크립션: desc || "",
                기준수량: bqty,
                제출수량: sqty,
                차이: delta,
                판정:
                  delta === 0 ? "OK" : delta > 0 ? `+${delta}` : `-${-delta}`,
                _cond: cfg.enabled ? "✓(기준합산·필터)" : "기준합산",
              });
              continue;
            }

            // 제출 품번합산
            if (cfg.aggregate) {
              const target =
                useDesc && desc && srec.byDesc.get(desc)
                  ? srec.byDesc.get(desc)
                  : srec.rows;
              let sqty = 0;
              if (cfg.enabled && (cfg.lvl || cfg.isv)) {
                for (const r of target) {
                  const ev = checkByCond(r, cfg);
                  if (ev.ok) sqty += r.qty || 0;
                }
              } else {
                sqty = target.reduce((a, r) => a + (r.qty || 0), 0);
              }
              const bqty = cfg.baseMerge
                ? baseTotal(baseBucket, part)
                : consumeBaseQty(baseBucket, part);
              const delta = sqty - bqty;
              out.push({
                _key: `${part}||${desc || ""}||${br.occIdx}`,
                _rk: rowKey(part, br.occIdx),
                품번: part,
                디스크립션: desc || "",
                기준수량: bqty,
                제출수량: sqty,
                차이: delta,
                판정:
                  delta === 0 ? "OK" : delta > 0 ? `+${delta}` : `-${-delta}`,
                _cond:
                  (cfg.baseMerge ? "기준합산" : "") +
                  (cfg.aggregate
                    ? (cfg.baseMerge ? " / " : "") + "품번합산"
                    : ""),
              });
              continue;
            }

            // 일반 매칭
            let rows = [],
              ukey = `${part}|*`;
            if (useDesc && desc && srec.byDesc.has(desc)) {
              rows = srec.byDesc.get(desc);
              ukey = `${part}|${desc}`;
            } else rows = srec.rows;

            const used = usedByKey.get(ukey) || new Set();
            const picked = takeNext(rows, cfg, used);
            usedByKey.set(ukey, used);
            if (!picked) continue;
            if (!picked.ok && !showFail) continue;

            const bqty = cfg.baseMerge
              ? baseTotal(baseBucket, part)
              : consumeBaseQty(baseBucket, part);
            const sqty = picked.row.qty;
            const delta = sqty - bqty;
            out.push({
              _key: `${part}||${desc || ""}||${br.occIdx}`,
              _rk: rowKey(part, br.occIdx),
              품번: part,
              디스크립션: desc || "",
              기준수량: bqty,
              제출수량: sqty,
              차이: delta,
              판정: delta === 0 ? "OK" : delta > 0 ? `+${delta}` : `-${-delta}`,
              _cond: picked.ok
                ? cfg.baseMerge
                  ? "✓(기준합산)"
                  : "✓"
                : picked.reason || "✕",
            });
          }
          result = out;
        }

        renderTable(result, defaults);
      } catch (err) {
        alert(err.message || String(err));
      }
    }

    /* ===== 사전설정 ===== */
    function parsePresetText(txt) {
      const lines = txt.replace(/\r/g, "").trim().split("\n").filter(x => x.trim() !== "");
      const map = {};
      for (const line of lines) {
        const cols = line.split("\t");
        const desc = (cols[0] || "").trim();
        if (!desc) continue;

        const lvl  = (cols[1] || "").trim();
        const isv  = (cols[2] || "").trim();
        const mode = ((cols[3] || "OR").trim().toUpperCase() === "AND") ? "AND" : "OR";
        const agg  = /^(Y|YES|TRUE|1)$/i.test((cols[4] || "").trim()); // 품번합산
        const base = /^(Y|YES|TRUE|1)$/i.test((cols[5] || "").trim()); // 기준합산 ★추가
        const en   = /^(Y|YES|TRUE|1)$/i.test((cols[6] || "").trim()); // 조건사용 ★추가

        map[keyDesc(desc)] = { lvl, isv, mode, aggregate: agg, baseMerge: base, enabled: en }; // ★추가
      }
      return map;
    }

    document.getElementById("presetSave").addEventListener("click", () => {
      const txt = document.getElementById("presetArea").value || "";
      descPresets = parsePresetText(txt);
      saveJson(PRESET_STORE_KEY, descPresets);
      alert("사전설정을 저장했습니다.");
    });
    document.getElementById("presetLoad").addEventListener("click", () => {
      descPresets = loadJson(PRESET_STORE_KEY, "{}");
      const rows = Object.entries(descPresets).map(([k, v]) =>
        [
          k,
          v.lvl || "",
          v.isv || "",
          v.mode || "OR",
          v.aggregate ? "Y" : "N",
          v.baseMerge ? "Y" : "N",     // ★ 기준합산
          v.enabled   ? "Y" : "N",     // ★ 조건사용
        ].join("\t")
      );
      document.getElementById("presetArea").value = rows.length ? rows.join("\n") : "";
      alert("저장된 사전설정을 불러왔습니다.");
    });

    document.getElementById("presetClear").addEventListener("click", () => {
      localStorage.removeItem(PRESET_STORE_KEY);
      descPresets = {};
      document.getElementById("presetArea").value = "";
      alert("사전설정을 삭제했습니다.");
    });

    /* ===== 초기화 ===== */
    document.getElementById("resetAll").addEventListener("click", () => {
      localStorage.removeItem(PERCOND_STORE_KEY);
      localStorage.removeItem(CHECK_STORE_KEY);
      if (document.getElementById("resetAlsoPreset").checked)
        localStorage.removeItem(PRESET_STORE_KEY);
      perCondMap = {};
      checkMap = {};
      descPresets = {};
      alert("저장된 설정을 삭제했습니다.");
    });

    /* ===== 붙여넣기/옵션 자동 저장 & 복원 ===== */
    function saveDraft() {
      try {
        localStorage.setItem(
          DRAFT_KEYS.base,
          document.getElementById("base").value || ""
        );
        localStorage.setItem(
          DRAFT_KEYS.subm,
          document.getElementById("subm").value || ""
        );
        const snapshot = {
          useDesc: !!document.getElementById("useDesc")?.checked,
          mergeBaseDup: !!document.getElementById("mergeBaseDup")?.checked,
          advCondEnabled: !!document.getElementById("advCondEnabled")?.checked,
          lvlCol: document.getElementById("lvlCol")?.value ?? "",
          lvlVal: document.getElementById("lvlVal")?.value ?? "",
          isCol: document.getElementById("isCol")?.value ?? "",
          isVal: document.getElementById("isVal")?.value ?? "",
          condMode: document.getElementById("condMode")?.value ?? "OR",
          aggMode: !!document.getElementById("aggMode")?.checked,
          aggCondOnly: !!document.getElementById("aggCondOnly")?.checked,
          showCheckedOnly:
            !!document.getElementById("showCheckedOnly")?.checked,
          showFailedCond: !!document.getElementById("showFailedCond")?.checked,
          presetArea: document.getElementById("presetArea")?.value ?? "",
        };
        localStorage.setItem(DRAFT_KEYS.opts, JSON.stringify(snapshot));
      } catch (e) {}
    }
    function loadDraft() {
      try {
        const b = localStorage.getItem(DRAFT_KEYS.base);
        const s = localStorage.getItem(DRAFT_KEYS.subm);
        if (b !== null) document.getElementById("base").value = b;
        if (s !== null) document.getElementById("subm").value = s;
        const raw = localStorage.getItem(DRAFT_KEYS.opts);
        if (raw) {
          const o = JSON.parse(raw);
          if ("useDesc" in o)
            document.getElementById("useDesc").checked = !!o.useDesc;
          if ("mergeBaseDup" in o)
            document.getElementById("mergeBaseDup").checked = !!o.mergeBaseDup;
          if ("advCondEnabled" in o)
            document.getElementById("advCondEnabled").checked =
              !!o.advCondEnabled;
          if ("lvlCol" in o) document.getElementById("lvlCol").value = o.lvlCol;
          if ("lvlVal" in o) document.getElementById("lvlVal").value = o.lvlVal;
          if ("isCol" in o) document.getElementById("isCol").value = o.isCol;
          if ("isVal" in o) document.getElementById("isVal").value = o.isVal;
          if ("condMode" in o)
            document.getElementById("condMode").value = o.condMode;
          if ("aggMode" in o)
            document.getElementById("aggMode").checked = !!o.aggMode;
          if ("aggCondOnly" in o)
            document.getElementById("aggCondOnly").checked = !!o.aggCondOnly;
          if ("showCheckedOnly" in o)
            document.getElementById("showCheckedOnly").checked =
              !!o.showCheckedOnly;
          if ("showFailedCond" in o)
            document.getElementById("showFailedCond").checked =
              !!o.showFailedCond;
          if ("presetArea" in o && document.getElementById("presetArea"))
            document.getElementById("presetArea").value = o.presetArea;
        }
      } catch (e) {}
    }
    let _draftTimer = null;
    function scheduleSave() {
      clearTimeout(_draftTimer);
      _draftTimer = setTimeout(saveDraft, 200);
    }
    ["base", "subm", "presetArea"].forEach((id) => {
      const el = document.getElementById(id);
      if (el) el.addEventListener("input", scheduleSave);
    });
    [
      "useDesc",
      "mergeBaseDup",
      "advCondEnabled",
      "lvlCol",
      "lvlVal",
      "isCol",
      "isVal",
      "condMode",
      "aggMode",
      "aggCondOnly",
      "showCheckedOnly",
      "showFailedCond",
    ].forEach((id) => {
      const el = document.getElementById(id);
      if (!el) return;
      const evt =
        el.tagName === "SELECT" || el.type === "checkbox" ? "change" : "input";
      el.addEventListener(evt, scheduleSave);
    });
    loadDraft();
    window.addEventListener("beforeunload", saveDraft);

function bindRowHover(table) {
  if (!table) return;

  let lastRow = null;

  function clear() {
    if (lastRow) {
      lastRow.classList.remove('rowhl');
      lastRow = null;
    }
  }

  table.addEventListener('mousemove', (e) => {
    const row = e.target.closest('tr');
    if (!row || !table.contains(row) || row === lastRow) return;

    clear();
    row.classList.add('rowhl');
    lastRow = row;
  });

  table.addEventListener('mouseleave', clear);
}


    // 전역 옵션 UI 숨김
    if (typeof DISABLE_GLOBALS !== "undefined" && DISABLE_GLOBALS) {
      [
        "mergeBaseDup",
        "advCondEnabled",
        "lvlCol",
        "lvlVal",
        "isCol",
        "isVal",
        "condMode",
        "aggMode",
        "aggCondOnly",
      ].forEach((id) => {
        const el = document.getElementById(id);
        if (!el) return;
        const holder = el.closest("label") || el.closest(".bar");
        if (holder) holder.style.display = "none";
      });
    }
  </script>
</html>
